@precedence {
  attribute @left,
  structure @left,
  valueOp @left
}

@skip { whitespace | Comment }

@top[name=StyleSheet,lang=css] { item+ }

item {
  RuleSet |
  ImportStatement |
  MediaStatement |
  CharsetStatement |
  NamespaceStatement |
  KeyframesStatement |
  SupportsStatement |
  AtRule
}

RuleSet {
  selector ("," selector)* Block
}

ImportStatement {
  @specialize[name=import,style=keyword.define]<AtKeyword, "@import"> value commaSep<query> ";"
}

MediaStatement {
  @specialize[name=media,style=keyword.control]<AtKeyword, "@media"> commaSep<query> Block
}

CharsetStatement {
  @specialize[name=charset,style=keyword.define]<AtKeyword, "@charset"> value ";"
}

NamespaceStatement {
  @specialize[name=namespace,style=keyword.define]<AtKeyword, "@namespace">
  NamespaceName[style=name.namespace] { identifier }?
  (StringLiteral | CallLiteral) ";"
}

KeyframesStatement {
  @specialize[name=keyframes,style=keyword.define]<AtKeyword, "@keyframes">
  KeyframeName[style=name.label] { identifier }
  KeyframeList
}

KeyframeList {
  "{" ((kw<"from"> | kw<"to"> | NumberLiteral) Block)* "}"
}

SupportsStatement {
  @specialize[name=supports,style=keyword.control]<AtKeyword, "@supports"> query Block
}

AtRule { AtKeyword commaSep<query> (";" | Block) }

Block { "{" ~item item* (Declaration (";" ~item item* Declaration?)*)? "}" }

selector {
  UniversalSelector |
  TagSelector { ~item TagName[style=name.type] { identifier } } |
  NestingSelector |
  ClassSelector { selector? !attribute "." ClassName[style=name.class] { identifier } } |
  PseudoClassSelector {
    selector? !attribute (":" | "::") (
      PseudoClassName[style=name.constant] { identifier } |
      @specialize[name=not,style=name.constant]<callee, "not"> ArgList<selector> |      
      PseudoClassName[style=name.constant] { callee } ArgList<value+>) } |
  IdSelector { selector? !attribute "#" IdName[style=name.label] { identifier } } |
  AttributeSelector { selector? !attribute "[" AttributeName[style=name.property] { identifier } (MatchOp value)? "]" } |
  ChildSelector { selector !structure ChildOp selector } |
  DescendantSelector { selector !structure descendantOp selector } |
  SiblingSelector { selector !structure SiblingOp selector }
}

NumberLiteral[style=literal.number] {
  numberLiteralInner Unit?
}

ArgList<content> { "(" commaSep<content> ")" }

Declaration {
  PropertyName[style=name.property] { identifier } defColon value (","? value)* Important?
}

query {
  KeywordQuery[style=keyword] { identifier } |
  FeatureQuery { "(" FeatureName[style=name.property] { identifier } defColon value+ ")" } |
  BinaryQuery { query !valueOp LogicOp query } |
  UnaryQuery { @specialize[name=UnaryQueryOp,style=keyword.operator]<identifier, "not" | "only"> query } |
  ParenthesizedQuery { "(" query ")" } |
  SelectorQuery { @specialize[name=callee,style=keyword]<callee, "selector"> "(" selector ")" }
}

value {
  ValueName[style=name.value] { identifier } |
  ParenthesizedValue { "(" value ")" } |
  ColorLiteral |
  NumberLiteral |
  StringLiteral |
  BinaryExpression { value !valueOp BinOp value } |
  CallExpression |
  CallLiteral
}

CallLiteral {
  @specialize[name=CallTag,style=keyword.expression]<callee, "url" | "url-prefix" | "domain" | "regexp">
  "(" (ParenthesizedContent | StringLiteral) ")"
}

CallExpression {
  Callee[style=name.variable] { callee } ArgList<value+>
}

commaSep<value> { "" | value ("," value)* }

kw<term> { @specialize[name={term},style=keyword]<identifier, term> }

@external tokens descendant from "./tokens" {
  descendantOp
}

@external tokens unitToken from "./tokens" {
  Unit[style=keyword.unit]
}

@external tokens identifiers from "./tokens" {
  callee,
  identifier
}

@tokens {
  UniversalSelector[style=operator.define] { "*" }

  NestingSelector[style=operator.define] { "&" }

  AtKeyword[style=keyword] { "@" std.asciiLetter (std.asciiLetter | std.digit | "-")* }

  MatchOp[style=operator.compare] { $[~^|*$]? "=" }

  ChildOp[style=operator.logic] { ">" ">"? }

  SiblingOp[style=operator.logic] { "~" | "+" }

  LogicOp[style=operator.logic] { "and" | "or" }

  BinOp[style=operator.arithmetic] { $[+\-*/] }

  Important[style=keyword.modifier] { "!important" }

  whitespace { std.whitespace+ }

  Comment[style=comment.block] { "/*" commentRest }

  commentRest { ![*] commentRest | "*" commentAfterStar }

  commentAfterStar { "/" | "*" commentAfterStar | ![/*] commentRest }

  @precedence { Comment, BinOp }

  hexDigit { std.digit | $[a-fA-F] }

  ParenthesizedContent[style=literal] { !['")] ![)]+ }

  @precedence { whitespace, ParenthesizedContent, Comment }

  ColorLiteral[style=literal.color] {
    "#" hexDigit hexDigit hexDigit (hexDigit (hexDigit hexDigit (hexDigit hexDigit)?)?)?
  }

  numberLiteralInner { ("+" | "-")? (std.digit+ ("." std.digit*)? | "." std.digit+) (("e" | "E") ("+" | "-")? std.digit+)? }

  @precedence { numberLiteralInner, BinOp, SiblingOp }

  StringLiteral[style=literal.string] { "\"" (!["\n\\] | "\\" _)* "\"" | "'" (!['\n\\] | "\\" _)* "'" }

  defColon[name="\":\"",style=punctuation.define] { ":" }

  "::"[style=operator.deref]
  ":"[style=operator.deref]
  "#"[style=operator.deref]

  ";"[style=punctuation.separator]
  ","[style=punctuation.separator]

  "("[style=bracket.paren.open]
  ")"[style=bracket.paren.close]
  "["[style=bracket.square.open]
  "]"[style=bracket.square.close]
  "{"[style=bracket.brace.open]
  "}"[style=bracket.brace.close]
}

@detectDelim
