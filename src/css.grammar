@precedence {
  attribute @left,
  structure @left,
  valueOp @left
}

@skip { whitespace | comment }

@top:stylesheet.document.lang=css { item+ }

item {
  ruleSet |
  importStatement |
  mediaStatement |
  charsetStatement |
  namespaceStatement |
  keyframesStatement |
  supportsStatement |
  atRule
}

ruleSet:ruleSet.declaration.statement {
  selector ("," selector)* block
}

importStatement:import.declaration.statement {
  @specialize<atKeyword, "@import", :import.at.keyword> value commaSep<query> ";"
}

mediaStatement:media.statement {
  @specialize<atKeyword, "@media", :media.at.keyword> commaSep<query> block
}

charsetStatement:charset.declaration.statement {
  @specialize<atKeyword, "@charset", :charset.at.keyword> value ";"
}

namespaceStatement:namespace.declaration.statement {
  @specialize<atKeyword, "@namespace", :namespace.at.keyword>
  identifier:namespace.definition.name?
  (stringLiteral | callLiteral) ";"
}

keyframesStatement:keyframes.statement {
  @specialize<atKeyword, "@keyframes", :keyframes.at.keyword> identifier:keyframes.definition.name keyframeList
}

keyframeList:keyframe.list.block {
  "{" ((kw<"from"> | kw<"to"> | numberLiteral) block)* "}"
}

supportsStatement:supports.declaration.statement {
  @specialize<atKeyword, "@supports", :supports.at.keyword> query block
}

atRule:atRule.statement { atKeyword commaSep<query> (";" | block) }

block:block { "{" ~item item* (declaration (";" ~item item* declaration?)*)? "}" }

selector {
  universalSelector |
  (~item identifier):tag.name.selector |
  nestingSelector |
  (selector? !attribute "." identifier:class.name):class.selector |
  (selector? !attribute (":" | "::") (
    identifier:pseudoClass.name |
    @specialize<callee, "not", :pseudoClass.name> argList<selector> |
    callee:pseudoClass.name argList<value+>)):pseudoClass.selector |
  (selector? !attribute "#" identifier:id.name):id.selector |
  (selector? !attribute "[" identifier:attribute.name (matchOp value)? "]"):attribute.selector |
  (selector !structure childOp selector):child.selector |
  (selector !structure descendantSelector selector):descendant.selector |
  (selector !structure siblingOp selector):sibling.selector
}

numberLiteral:number.literal.expression {
  numberLiteralInner unit?
}

argList<content>:argument.list { "(" commaSep<content> ")" }

declaration:property.declaration.statement {
  identifier:property.name ":" value (","? value)* important?
}

query {
  identifier:keyword.query |
  ("(" identifier:feature.name ":" value+ ")"):feature.query |
  (query !valueOp logicOp query):binary.operator.query |
  (@specialize<identifier, "not" | "only", :operator.keyword> query):unary.operator.query |
  ("(" query ")"):parenthesized.query |
  (@specialize<callee, "selector", :selector.keyword> "(" selector ")"):selector.query
}

value {
  identifier:value.name.expression |
  ("(" value ")"):parenthesized.expression |
  colorLiteral |
  numberLiteral |
  stringLiteral |
  (value !valueOp binOp value):binary.operator.expression |
  callExpression |
  callLiteral
}

callLiteral:call.literal.expression {
  @specialize<callee, "url" | "url-prefix" | "domain" | "regexp", :callee.name> "(" (parenthesizedContent | stringLiteral) ")"
}

callExpression:call.expression {
  callee:callee.name argList<value+>
}

commaSep<value> { "" | value ("," value)* }

kw<term> { @specialize<identifier, term, :$term.keyword> }

@external-tokens descendant from "./tokens" {
  descendantSelector
}

@external-tokens unitToken from "./tokens" {
  unit:unit.name
}

@external-tokens identifiers from "./tokens" {
  callee,
  identifier
}

@tokens {
  universalSelector:universal.operator.name { "*" }

  nestingSelector:nesting.operator.name { "&" }

  atKeyword:at.keyword { "@" std.asciiLetter (std.asciiLetter | std.digit | "-")* }

  matchOp:operator.name { [~^|*$]? "=" }

  childOp:operator.name { ">" ">"? }

  siblingOp:operator.name { "~" | "+" }

  logicOp:operator.name { "and" | "or" }

  binOp:operator.name { [+\-*/] }

  important:important.keyword { "!important" }

  whitespace { std.whitespace+ }

  comment:block.comment { "/*" commentRest }

  commentRest { [^*] commentRest | "*" commentAfterStar }

  commentAfterStar { "/" | "*" commentAfterStar | [^/*] commentRest }

  @precedence { comment, binOp }

  hexDigit { std.digit | [a-fA-F] }

  parenthesizedContent:parenthesized.content { [^'")] [^)]+ }

  @precedence { whitespace, parenthesizedContent, comment }

  colorLiteral:color.literal.expression {
    "#" hexDigit hexDigit hexDigit (hexDigit (hexDigit hexDigit (hexDigit hexDigit)?)?)?
  }

  numberLiteralInner { ("+" | "-")? (std.digit+ ("." std.digit*)? | "." std.digit+) (("e" | "E") ("+" | "-")? std.digit+)? }

  @precedence { numberLiteralInner, binOp, siblingOp }

  stringLiteral:string.literal.expression { "\"" ([^"\n\\] | "\\" _)* "\"" | "'" ([^'\n\\] | "\\" _)* "'" }
}

@tags {
  @detect-delim
  @punctuation<"()[]{},:.;#">
  "::":doubleColon.punctuation
}
