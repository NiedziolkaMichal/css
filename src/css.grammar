precedence {
  attribute left,
  structure left,
  valueOp left
}

skip { whitespace | Comment }

top { item+ }

item {
  RuleSet |
  ImportStatement |
  MediaStatement |
  CharsetStatement |
  NamespaceStatement |
  KeyframesStatement |
  SupportsStatement |
  AtRule
}

RuleSet { selector ("," selector)* Block }

ImportStatement { specialize<AtKeyword, "@import"> value commaSep<query> ";" }

MediaStatement { specialize<AtKeyword, "@media"> commaSep<query> Block }

CharsetStatement { specialize<AtKeyword, "@charset"> value ";" }

NamespaceStatement { specialize<AtKeyword, "@namespace"> tag.Def<identifier>? (StringLiteral | CallExpression) ";" }

KeyframesStatement { specialize<AtKeyword, "@keyframes"> tag.Def<identifier> KeyframeList }

KeyframeList { "{" ((kw<"from"> | kw<"to"> | NumberLiteral) Block)* "}" }

SupportsStatement { specialize<AtKeyword, "@supports"> query Block }

AtRule { AtKeyword commaSep<query> (";" | Block) }

Block { "{"  ~item item* (Declaration (";" ~item item* Declaration?)*)? "}" }

selector {
  UniversalSelector |
  tag.TagName<~item identifier> |
  NestingSelector |
  tag.ClassSelector<selector? !attribute "." tag.ClassName<identifier>> |
  tag.PseudoClassSelector<selector? !attribute (":" | "::") (
    tag.PseudoClassName<identifier> |
    specialize<callee, "not", PseudoClassName> ArgList<selector> |
    tag.PseudoClassName<callee> ArgList<value+>)> |
  tag.IdSelector<selector? !attribute "#" tag.IdName<identifier>> |
  tag.AttributeSelector<selector? !attribute "[" tag.AttributeName<identifier> (matchOp value)? "]"> |
  tag.ChildSelector<selector !structure childOp selector> |
  tag.DescendantSelector<selector !structure descendantSelector selector> |
  tag.SiblingSelector<selector !structure siblingOp selector>
}

NumberLiteral {
  numberLiteral Unit?
}

ArgList<content> { "(" commaSep<content> ")" }

Declaration {
  tag.PropertyName<identifier> ":" value (","? value)* Important?
}

query {
  tag.KeywordQuery<identifier> |
  tag.FeatureQuery<"(" tag.FeatureName<identifier> ":" value+ ")"> |
  tag.BinaryQuery<query !valueOp logicOp query> |
  // FIXME tag.UnaryQuery<("not" | "only") query> |
  tag.ParenthesizedQuery<"(" query ")"> //|
//  tag.SelectorQuery<kw<"selector"> "(" selector ")"> FIXME
}

value {
  tag.Value<identifier> |
  tag.ParenthesizedValue<"(" value ")"> |
  ColorLiteral |
  NumberLiteral |
  StringLiteral |
  tag.BinaryExpression<value !valueOp binOp value> |
  CallExpression |
  tag.CallLiteral<specialize<callee, "url" | "url-prefix" | "domain" | "regexp"> "(" (ParenthesizedContent | StringLiteral) ")">
}

CallExpression {
  tag.Callee<callee> ArgList<value+>
}

commaSep<value> { "" | value ("," value)* }

kw<term> { specialize<identifier, term, Keyword> }

external tokens descendant from "./tokens" {
  descendantSelector
}

external tokens unit from "./tokens" {
  Unit
}

external tokens identifiers from "./tokens" {
  callee,
  identifier
}

tokens {
  UniversalSelector { "*" }

  NestingSelector { "&" }

  AtKeyword { "@" std.asciiLetter (std.asciiLetter | std.digit | "-")* }

  matchOp=Operator { [~^|*$]? "=" }

  childOp=Operator { ">" ">"? }

  siblingOp=Operator { "~" | "+" }

  logicOp=Operator { "and" | "or" }

  binOp=Operator { [+\-*/] }

  Important { "!important" }

  whitespace { std.whitespace+ }

  Comment { "/*" commentRest }

  commentRest { [^*] commentRest | "*" commentAfterStar }

  commentAfterStar { "/" | "*" commentAfterStar | [^/*] commentRest }

  precedence { Comment, binOp }

  hexDigit { std.digit | [a-fA-F] }

  ParenthesizedContent { [^'")] [^)]+ }

  precedence { whitespace, ParenthesizedContent, Comment }

  ColorLiteral { "#" hexDigit hexDigit hexDigit (hexDigit (hexDigit hexDigit (hexDigit hexDigit)?)?)? }

  numberLiteral { ("+" | "-")? (std.digit+ ("." std.digit*)? | "." std.digit+) (("e" | "E") ("+" | "-")? std.digit+)? }

  precedence { numberLiteral, binOp, siblingOp }

  StringLiteral { "\"" ([^"\n\\] | "\\" _)* "\"" | "'" ([^'\n\\] | "\\" _)* "'" }
}

