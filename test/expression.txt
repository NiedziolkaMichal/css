# Strings

"A string with \"double\" and 'single' quotes";
'A string with "double" and \'single\' quotes';
'\\';
"\\";

'A string with new \
line';

==>

ExpressionStatement(String), ExpressionStatement(String), ExpressionStatement(String),
ExpressionStatement(String), ExpressionStatement(String)

# Numbers

101;
3.14;
3.14e+1;
0x1ABCDEFabcdef;
0o7632157312;
0b1010101001;
1e+3;

==>

ExpressionStatement(Number), ExpressionStatement(Number), ExpressionStatement(Number), ExpressionStatement(Number),
ExpressionStatement(Number), ExpressionStatement(Number), ExpressionStatement(Number)

# Identifiers

theVar;
theVar2;
$_;
é象𫝄;
últimaVez;
県;

==>

ExpressionStatement(Variable), ExpressionStatement(Variable), ExpressionStatement(Variable),
ExpressionStatement(Variable), ExpressionStatement(Variable), ExpressionStatement(Variable)

# RegExps

/one\\/;
/one/g;
/one/i;
/one/gim;
/on\/e/gim;
/on[^/]afe/gim;
/[\]/]/;

==>

ExpressionStatement(RegExp), ExpressionStatement(RegExp), ExpressionStatement(RegExp), ExpressionStatement(RegExp),
ExpressionStatement(RegExp), ExpressionStatement(RegExp), ExpressionStatement(RegExp)

# Arrays

[];
[ "item1" ];
[ "item1", ];
[ "item1", item2 ];
[ , item2 ];
[ item2 = 5 ];

==>

ExpressionStatement(ArrayExpression),
ExpressionStatement(ArrayExpression(String)),
ExpressionStatement(ArrayExpression(String)),
ExpressionStatement(ArrayExpression(String, Variable)),
ExpressionStatement(ArrayExpression(Variable)),
ExpressionStatement(ArrayExpression(AssignmentExpression(Variable, Operator, Number)))

# Functions

[
  function() {},
  function(arg1, ...arg2) {
    arg2;
  },
  function stuff() {},
  function trailing(a,) {},
  function trailing(a,b,) {}
]

==>

ExpressionStatement(ArrayExpression(
  FunctionExpression(Keyword, ParamList, Block),
  FunctionExpression(Keyword, ParamList(Definition, Definition), Block(ExpressionStatement(Variable))),
  FunctionExpression(Keyword, Definition, ParamList, Block),
  FunctionExpression(Keyword, Definition, ParamList(Definition), Block),
  FunctionExpression(Keyword, Definition, ParamList(Definition, Definition), Block)))

# Arrow functions

a => 1;
() => 2;
(d, e) => 3;
(f, g,) => {
  return h;
};
async () => 4;

==>

ExpressionStatement(ArrowFunction(ParamList(Definition), Number)),
ExpressionStatement(ArrowFunction(ParamList, Number)),
ExpressionStatement(ArrowFunction(ParamList(Definition, Definition), Number)),
ExpressionStatement(ArrowFunction(ParamList(Definition, Definition), Block(ReturnStatement(Keyword, Variable)))),
ExpressionStatement(ArrowFunction(Keyword, ParamList, Number))

# Long potential arrow function

(assign = [to, from], from = assign[0], to = assign[1]);

==>

ExpressionStatement(ParenthesizedExpression(
  SequenceExpression(
    AssignmentExpression(Variable, Operator, ArrayExpression(Variable, Variable)),
    AssignmentExpression(Variable, Operator, MemberExpression(Variable, Number)),
    AssignmentExpression(Variable, Operator, MemberExpression(Variable, Number)))))

# Ternary operator

condition ? case1 : case2;

x.y = some.condition ? 2**x : 1 - 2;

==>

ExpressionStatement(ConditionalExpression(Variable, Operator, Variable, Operator, Variable)),

ExpressionStatement(AssignmentExpression(
  MemberExpression(Variable, PropertyName), Operator,
  ConditionalExpression(MemberExpression(Variable, PropertyName),
    Operator, BinaryExpression(Number, Operator, Variable),
    Operator, BinaryExpression(Number, Operator, Number))))

# Type operators

typeof x;
x instanceof String;

==>

ExpressionStatement(UnaryExpression(OperatorKeyword, Variable)),
ExpressionStatement(BinaryExpression(Variable, OperatorKeyword, Variable))

# Delete

delete thing['prop'];
true ? delete thing.prop : null;

==>

ExpressionStatement(UnaryExpression(OperatorKeyword, MemberExpression(Variable, String))),
ExpressionStatement(ConditionalExpression(Boolean, Operator,
  UnaryExpression(OperatorKeyword, MemberExpression(Variable, PropertyName)), Operator, Null))

# Void

a = void b();

==>

ExpressionStatement(AssignmentExpression(Variable, Operator, UnaryExpression(OperatorKeyword, CallExpression(Variable, ArgList))))

# Augmented assignment

s |= 1;
t %= 2;
w ^= 3;
x += 4;
y.z *= 5;
z += 1;
a >>= 1;
b >>>= 1;
c <<= 1;

==>

ExpressionStatement(AssignmentExpression(Variable, Operator, Number)),
ExpressionStatement(AssignmentExpression(Variable, Operator, Number)),
ExpressionStatement(AssignmentExpression(Variable, Operator, Number)),
ExpressionStatement(AssignmentExpression(Variable, Operator, Number)),
ExpressionStatement(AssignmentExpression(MemberExpression(Variable, PropertyName), Operator, Number)),
ExpressionStatement(AssignmentExpression(Variable, Operator, Number)),
ExpressionStatement(AssignmentExpression(Variable, Operator, Number)),
ExpressionStatement(AssignmentExpression(Variable, Operator, Number)),
ExpressionStatement(AssignmentExpression(Variable, Operator, Number))

# Operator precedence

a <= b && c >= d;
a.b = c ? d : e;
a && b(c) && d;
a && new b(c) && d;
typeof a == b && c instanceof d;

==>

ExpressionStatement(BinaryExpression(BinaryExpression(Variable, Operator, Variable), Operator, BinaryExpression(Variable, Operator, Variable))),
ExpressionStatement(AssignmentExpression(MemberExpression(Variable, PropertyName), Operator,
  ConditionalExpression(Variable, Operator, Variable, Operator, Variable))),
ExpressionStatement(BinaryExpression(BinaryExpression(Variable, Operator, CallExpression(Variable, ArgList(Variable))), Operator, Variable)),
ExpressionStatement(BinaryExpression(BinaryExpression(Variable, Operator, NewExpression(Keyword, Variable, ArgList(Variable))), Operator, Variable)),
ExpressionStatement(BinaryExpression(BinaryExpression(UnaryExpression(OperatorKeyword, Variable), Operator, Variable), Operator,
  BinaryExpression(Variable, OperatorKeyword, Variable)))

# Rest args

foo(...rest);

==>

ExpressionStatement(CallExpression(Variable, ArgList(Variable)))

# Forward slashes after parenthesized expressions

(foo - bar) / baz;
if (foo - bar) /baz/;
(this.a() / this.b() - 1) / 2;

==>

ExpressionStatement(BinaryExpression(ParenthesizedExpression(BinaryExpression(Variable, Operator, Variable)), Operator, Variable)),
IfStatement(Keyword, ParenthesizedExpression(BinaryExpression(Variable, Operator, Variable)), ExpressionStatement(RegExp)),
ExpressionStatement(BinaryExpression(
  ParenthesizedExpression(
    BinaryExpression(BinaryExpression(CallExpression(MemberExpression(This, PropertyName), ArgList), Operator,
                                      CallExpression(MemberExpression(This, PropertyName), ArgList)),
                     Operator, Number)),
  Operator, Number))

# Yield expressions

yield db.users.where('[endpoint+email]');

==>

ExpressionStatement(UnaryExpression(Keyword,
  CallExpression(MemberExpression(MemberExpression(Variable, PropertyName), PropertyName), ArgList(String))))

# Template strings

`one line`;
`multi
  line`;

`multi
  ${2 + 2}
  hello
  ${1, 2}
  line`;

`$$$$`;
`$`;
`$$$$${ async }`;

`\\`;

`one${`two${`three`}`}`;

f`hi${there}`;

==>

ExpressionStatement(TemplateString(Template, Template, Template)),
ExpressionStatement(TemplateString(Template, Template, Template)),
ExpressionStatement(TemplateString(Template, Template, BinaryExpression(Number, Operator, Number),
  Template, SequenceExpression(Number, Number), Template, Template)),
ExpressionStatement(TemplateString(Template, Template, Template)),
ExpressionStatement(TemplateString(Template, Template, Template)),
ExpressionStatement(TemplateString(Template, Template, Variable, Template)),
ExpressionStatement(TemplateString(Template, Template, Template)),
ExpressionStatement(TemplateString(Template, Template,
  TemplateString(Template, Template, TemplateString(Template, Template, Template), Template), Template)),
ExpressionStatement(TaggedTemplateExpression(Variable, TemplateString(Template, Template, Variable, Template)))

# Atoms

this;
null;
undefined;
true;
false;

==> ExpressionStatement(This), ExpressionStatement(Null), ExpressionStatement(Variable), ExpressionStatement(Boolean), ExpressionStatement(Boolean)

# Objects

foo({},
    { a: "b" },
    { c: "d", "e": f, 1: 2 },
    {
      g,
      [methodName]() {}
    },
    {b, get},
    {a,});

==>

ExpressionStatement(CallExpression(Variable, ArgList(
  ObjectExpression,
  ObjectExpression(Property(PropertyName, String)),
  ObjectExpression(Property(PropertyName, String), Property(String, Variable), Property(Number, Number)),
  ObjectExpression(Property(PropertyName), Property(Variable, ParamList, Block)),
  ObjectExpression(Property(PropertyName), Property(PropertyName)),
  ObjectExpression(Property(PropertyName)))))

# Method definitions

({
  foo: true,

  add(a, b) {
    return a + b;
  },

  get bar() { return c; },

  set bar(a) { c = a; },

  *barGenerator() { yield c; },

  get() { return 1; }
});

==>

ExpressionStatement(ParenthesizedExpression(
  ObjectExpression(
    Property(PropertyName, Boolean),
    Property(PropertyName, ParamList(Definition, Definition), Block(ReturnStatement(Keyword, BinaryExpression(Variable, Operator, Variable)))),
    Property(Keyword, PropertyName, ParamList, Block(ReturnStatement(Keyword, Variable))),
    Property(Keyword, PropertyName, ParamList(Definition), Block(ExpressionStatement(AssignmentExpression(Variable, Operator, Variable)))),
    Property(Star, PropertyName, ParamList, Block(ExpressionStatement(UnaryExpression(Keyword, Variable)))),
    Property(PropertyName, ParamList, Block(ReturnStatement(Keyword, Number))))))

# Keyword property names

({
  finally() {},
  catch() {},
  get: function () {},
  set() {},
  static: true,
  async: true,
});

==>

ExpressionStatement(ParenthesizedExpression(ObjectExpression(
  Property(PropertyName, ParamList, Block),
  Property(PropertyName, ParamList, Block),
  Property(PropertyName, FunctionExpression(Keyword, ParamList, Block)),
  Property(PropertyName, ParamList, Block),
  Property(PropertyName, Boolean),
  Property(PropertyName, Boolean))))

# Generator functions

[
  function *() {},
  function *generateStuff(arg1, arg2) {
    yield;
    yield arg2;
  }
];

==>

ExpressionStatement(ArrayExpression(
  FunctionExpression(Keyword, Star, ParamList, Block),
  FunctionExpression(Keyword, Star, Definition, ParamList(Definition, Definition), Block(
    ExpressionStatement(Variable),
    ExpressionStatement(UnaryExpression(Keyword, Variable))))))

# Member expressions

x.someProperty;
x[someVariable];
f()["some-string"];
return returned.promise().done(a).fail(b);

==>

ExpressionStatement(MemberExpression(Variable, PropertyName)),
ExpressionStatement(MemberExpression(Variable, Variable)),
ExpressionStatement(MemberExpression(CallExpression(Variable, ArgList), String)),

ReturnStatement(Keyword, CallExpression(
  MemberExpression(CallExpression(
    MemberExpression(CallExpression(
      MemberExpression(Variable, PropertyName), ArgList), PropertyName), ArgList(Variable)), PropertyName), ArgList(Variable)))

# Callback chain

return this.map(function (a) {
  return a.b;
})

// a comment

.filter(function (c) {
  return 2;
});

==>

ReturnStatement(Keyword, CallExpression(
  MemberExpression(CallExpression(
    MemberExpression(This, PropertyName), ArgList(FunctionExpression(Keyword, ParamList(Definition), Block(
      ReturnStatement(Keyword, MemberExpression(Variable, PropertyName)))))),
    LineComment,
    PropertyName),
  ArgList(FunctionExpression(Keyword, ParamList(Definition), Block(ReturnStatement(Keyword, Number))))))

# Function calls

x.someMethod(arg1, "arg2");
(function(x, y) {

}(a, b));
f(new foo.bar(1), 2);

==> 

ExpressionStatement(CallExpression(MemberExpression(Variable, PropertyName), ArgList(Variable, String))),
ExpressionStatement(ParenthesizedExpression(CallExpression(FunctionExpression(Keyword, ParamList(Definition, Definition), Block),
  ArgList(Variable, Variable)))),
ExpressionStatement(CallExpression(Variable, ArgList(NewExpression(Keyword, MemberExpression(Variable, PropertyName), ArgList(Number)), Number)))

# Constructor calls

new foo(1);
new module.Klass(1, "two");
new Thing;

==>

ExpressionStatement(NewExpression(Keyword, Variable, ArgList(Number))),
ExpressionStatement(NewExpression(Keyword, MemberExpression(Variable, PropertyName), ArgList(Number, String))),
ExpressionStatement(NewExpression(Keyword, Variable))

# Await Expressions

await asyncFunction();
await asyncPromise;

==>

ExpressionStatement(UnaryExpression(Keyword, CallExpression(Variable, ArgList))),
ExpressionStatement(UnaryExpression(Keyword, Variable))

# Numeric operators

i++;
i--;
i + j * 3 - j % 5;
2 ** i * 3;
2 * i ** 3;
+x;
-x;

==>

ExpressionStatement(UnaryExpression(Variable, Operator)),
ExpressionStatement(UnaryExpression(Variable, Operator)),
ExpressionStatement(BinaryExpression(
  BinaryExpression(Variable, Operator, BinaryExpression(Variable, Operator, Number)),
  Operator,
  BinaryExpression(Variable, Operator, Number))),
ExpressionStatement(BinaryExpression(BinaryExpression(Number, Operator, Variable), Operator, Number)),
ExpressionStatement(BinaryExpression(Number, Operator, BinaryExpression(Variable, Operator, Number))),
ExpressionStatement(UnaryExpression(Operator, Variable)),
ExpressionStatement(UnaryExpression(Operator, Variable))

# Boolean operators

i || j;
i && j;
!a && !b || !c && !d;

==>

ExpressionStatement(BinaryExpression(Variable, Operator, Variable)),
ExpressionStatement(BinaryExpression(Variable, Operator, Variable)),
ExpressionStatement(BinaryExpression(
  BinaryExpression(UnaryExpression(Operator, Variable), Operator, UnaryExpression(Operator, Variable)),
  Operator,
  BinaryExpression(UnaryExpression(Operator, Variable), Operator, UnaryExpression(Operator, Variable))))

# Bitwise operators

i >> j;
i >>> j;
i << j;
i & j;
i | j;
~i ^ ~j;

==>

ExpressionStatement(BinaryExpression(Variable, Operator, Variable)),
ExpressionStatement(BinaryExpression(Variable, Operator, Variable)),
ExpressionStatement(BinaryExpression(Variable, Operator, Variable)),
ExpressionStatement(BinaryExpression(Variable, Operator, Variable)),
ExpressionStatement(BinaryExpression(Variable, Operator, Variable)),
ExpressionStatement(BinaryExpression(UnaryExpression(Operator, Variable), Operator, UnaryExpression(Operator, Variable)))

# Relational operators

x < y;
x <= y;
x == y;
x === y;
x != y;
x !== y;
x > y;
x >= y;

==>

ExpressionStatement(BinaryExpression(Variable, Operator, Variable)),
ExpressionStatement(BinaryExpression(Variable, Operator, Variable)),
ExpressionStatement(BinaryExpression(Variable, Operator, Variable)),
ExpressionStatement(BinaryExpression(Variable, Operator, Variable)),
ExpressionStatement(BinaryExpression(Variable, Operator, Variable)),
ExpressionStatement(BinaryExpression(Variable, Operator, Variable)),
ExpressionStatement(BinaryExpression(Variable, Operator, Variable)),
ExpressionStatement(BinaryExpression(Variable, Operator, Variable))

# Word operators

x in y;
x instanceof y;
!x instanceof y;

==>

ExpressionStatement(BinaryExpression(Variable, OperatorKeyword, Variable)),
ExpressionStatement(BinaryExpression(Variable, OperatorKeyword, Variable)),
ExpressionStatement(BinaryExpression(UnaryExpression(Operator, Variable), OperatorKeyword, Variable))

# Assignments

x = 0;
x.y = 0;
x["y"] = 0;
async = 0;
[a, b = 2] = foo;
({a, b, ...d} = c);

==>

ExpressionStatement(AssignmentExpression(Variable, Operator, Number)),
ExpressionStatement(AssignmentExpression(MemberExpression(Variable, PropertyName), Operator, Number)),
ExpressionStatement(AssignmentExpression(MemberExpression(Variable, String), Operator, Number)),
ExpressionStatement(AssignmentExpression(Variable, Operator, Number)),
ExpressionStatement(AssignmentExpression(ArrayPattern(Definition, Definition, Operator, Number), Operator, Variable)),
ExpressionStatement(ParenthesizedExpression(
  AssignmentExpression(ObjectPattern(Property(PropertyName), Property(PropertyName), Property(Definition)), Operator, Variable)))

# Comma operator

a = 1, b = 2;
c = {d: (3, 4 + 5)};

==>

ExpressionStatement(SequenceExpression(AssignmentExpression(Variable, Operator, Number), AssignmentExpression(Variable, Operator, Number))),
ExpressionStatement(AssignmentExpression(Variable, Operator, ObjectExpression(
  Property(PropertyName, ParenthesizedExpression(SequenceExpression(Number, BinaryExpression(Number, Operator, Number)))))))

# Punctuation

(foo(1, 2), bar);

==>

ExpressionStatement(ParenthesizedExpression("(",
  SequenceExpression(CallExpression(Variable, ArgList("(", Number, ",", Number, ")")), ",",
  Variable), ")"), ";")
